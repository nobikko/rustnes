//! Main NES emulator struct that orchestrates all components

use crate::cpu::CPU;
use crate::ppu::PPU;
use crate::apu::APU;
use crate::rom::{Rom, MapperInterface, create_mapper, Mapper};
use crate::controller::ControllerPorts;

/// NTSC clock speed (Hz)
const CPU_FREQ_NTSC: f64 = 1789772.5;
const PPU_FREQ_NTSC: f64 = 5369317.5;  // 3x CPU

/// Frame timing constants
const DOTS_PER_SCANLINE: u16 = 341;
const SCANLINES_PER_FRAME: u16 = 262;

/// NES emulator struct
pub struct NES {
    pub cpu: CPU,
    pub ppu: PPU,
    pub apu: APU,
    pub mapper: Box<dyn MapperInterface>,
    pub controllers: ControllerPorts,

    pub rom: Option<Rom>,
    pub frame_count: u32,

    // Cycle tracking for synchronization
    pub cycle_count: u64,
    pub dots_since_last_cpu: u64,

    // Audio output callback
    pub on_audio_sample: Option<Box<dyn Fn(f32, f32) + Send + Sync>>,

    // Frame output callback
    pub on_frame: Option<Box<dyn Fn(&[u32]) + Send + Sync>>,

    // Debug output
    pub debug: bool,
}

impl NES {
    /// Create a new NES emulator instance
    pub fn new(sample_rate: u32) -> Self {
        Self {
            cpu: CPU::new(),
            ppu: PPU::new(),
            apu: APU::new(sample_rate),
            mapper: create_mapper(Mapper::NoMapper),
            controllers: ControllerPorts::new(),
            rom: None,
            frame_count: 0,
            cycle_count: 0,
            dots_since_last_cpu: 0,
            on_audio_sample: None,
            on_frame: None,
            debug: false,
        }
    }

    /// Load a ROM into the emulator
    pub fn load_rom(&mut self, rom: Rom) -> Result<(), &'static str> {
        // Create appropriate mapper based on ROM header
        self.mapper = create_mapper(rom.header.mapper);

        // Load ROM data into mapper
        self.mapper.load_rom(&rom);

        // Load PRG-ROM into CPU memory
        self.load_prg_rom(&rom)?;

        // Load CHR-ROM into PPU
        self.load_chr_rom(&rom);

        // Initialize nametables with visible content
        self.ppu.init_nametables();

        self.rom = Some(rom);

        // Reset CPU with new ROM
        self.cpu.reset();

        Ok(())
    }

    fn load_prg_rom(&mut self, rom: &Rom) -> Result<(), &'static str> {
        // Copy PRG-ROM to CPU memory ($8000-$FFFF)
        for (i, &byte) in rom.prg_rom.iter().enumerate() {
            let addr = 0x8000 + i;
            if addr < 0x10000 {
                self.cpu.memory[addr] = byte;
            }
        }

        // Also copy to $C000-$FFFF for smaller ROMs
        // This handles ROMs with less than 32KB PRG-ROM
        if rom.prg_rom.len() < 0x8000 {
            let prg_size = rom.prg_rom.len();
            for i in 0..prg_size {
                let addr = 0xC000 + i;
                if addr < 0x10000 {
                    self.cpu.memory[addr] = rom.prg_rom[i];
                }
            }
        }

        // Ensure reset vector at $FFFC-$FFFD points to a valid address
        // This is critical for the CPU to start executing at the right place
        // Use the last 2 bytes of PRG ROM as reset vector if available, otherwise use $8000
        let rom_size = rom.prg_rom.len();
        if rom_size >= 2 {
            let reset_vec = (rom_size as u16) - 2;
            self.cpu.memory[0xFFFC] = reset_vec as u8;
            self.cpu.memory[0xFFFD] = (reset_vec >> 8) as u8;
        } else {
            // Fallback to $8000 if ROM is too small
            self.cpu.memory[0xFFFC] = 0x00;
            self.cpu.memory[0xFFFD] = 0x80;
        }

        Ok(())
    }

    fn load_chr_rom(&mut self, rom: &Rom) {
        // Copy CHR-ROM to PPU VRAM
        for (i, &byte) in rom.chr_rom.iter().enumerate() {
            if i < self.ppu.vram.len() {
                self.ppu.vram[i] = byte;
            }
        }

        // If CHR ROM is empty or all zeros, load default font patterns
        // This allows ROMs that store text as ASCII bytes to display correctly
        let chr_rom_empty = rom.chr_rom.is_empty() || rom.chr_rom.iter().all(|&b| b == 0);
        if chr_rom_empty {
            self.load_default_font_patterns();
        }
    }

    /// Load default ASCII font patterns into PPU VRAM
    fn load_default_font_patterns(&mut self) {
        // Load a simple 8x8 font pattern for ASCII characters 0x20-0x7F
        // Patterns are stored at $0000-$0FFF (pattern table 0)
        for char_code in 0x20..0x80 {
            let pattern_offset = (char_code as usize) * 16;
            if pattern_offset + 16 <= self.ppu.vram.len() {
                // Generate simple 8x8 font pattern for this character
                let byte_data = Self::get_char_pattern(char_code);
                for i in 0..16 {
                    self.ppu.vram[pattern_offset + i] = byte_data[i];
                }
            }
        }
    }

    /// Generate 8x8 font pattern bytes for a character
    fn get_char_pattern(char_code: u8) -> [u8; 16] {
        // Simple 8x8 bitmap patterns for ASCII characters
        let patterns = [
            // Space (0x20)
            [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // ! (0x21)
            [0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00],
            // " (0x22)
            [0x00, 0x00, 0x00, 0x00, 0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // # (0x23)
            [0x00, 0x00, 0x00, 0x00, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // $ (0x24)
            [0x00, 0x18, 0x3C, 0x66, 0x66, 0x3C, 0x18, 0x00, 0x00, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00, 0x00],
            // % (0x25)
            [0x00, 0x66, 0x66, 0x3C, 0x18, 0x0C, 0x06, 0x00, 0x00, 0x66, 0x33, 0x19, 0x0C, 0x06, 0x66, 0x00],
            // & (0x26)
            [0x00, 0x3C, 0x66, 0x3C, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // ' (0x27)
            [0x00, 0x00, 0x00, 0x00, 0x36, 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // ( (0x28)
            [0x00, 0x00, 0x00, 0x00, 0x18, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00],
            // ) (0x29)
            [0x00, 0x00, 0x00, 0x00, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00],
            // * (0x2A)
            [0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x3C, 0xFE, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // + (0x2B)
            [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // , (0x2C)
            [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00],
            // - (0x2D)
            [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // . (0x2E)
            [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00],
            // / (0x2F)
            [0x00, 0x00, 0x00, 0x00, 0x06, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // 0 (0x30)
            [0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // 1 (0x31)
            [0x00, 0x18, 0x38, 0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // 2 (0x32)
            [0x00, 0x3C, 0x66, 0x06, 0x0C, 0x30, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // 3 (0x33)
            [0x00, 0x3C, 0x66, 0x06, 0x1C, 0x06, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // 4 (0x34)
            [0x00, 0x0C, 0x1C, 0x3C, 0x6C, 0x7E, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // 5 (0x35)
            [0x00, 0x7E, 0x60, 0x7C, 0x06, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // 6 (0x36)
            [0x00, 0x3C, 0x66, 0x60, 0x7C, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // 7 (0x37)
            [0x00, 0x7E, 0x66, 0x0C, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // 8 (0x38)
            [0x00, 0x3C, 0x66, 0x3C, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // 9 (0x39)
            [0x00, 0x3C, 0x66, 0x66, 0x7C, 0x60, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // : (0x3A)
            [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00],
            // ; (0x3B)
            [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00],
            // < (0x3C)
            [0x00, 0x00, 0x00, 0x00, 0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00],
            // = (0x3D)
            [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // > (0x3E)
            [0x00, 0x00, 0x00, 0x00, 0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00],
            // ? (0x3F)
            [0x00, 0x3C, 0x66, 0x06, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // @ (0x40)
            [0x00, 0x3C, 0x66, 0x66, 0x6E, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // A (0x41)
            [0x00, 0x3C, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // B (0x42)
            [0x00, 0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // C (0x43)
            [0x00, 0x3C, 0x66, 0x60, 0x60, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // D (0x44)
            [0x00, 0x78, 0x6C, 0x66, 0x66, 0x6C, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // E (0x45)
            [0x00, 0x7E, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // F (0x46)
            [0x00, 0x7E, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // G (0x47)
            [0x00, 0x3C, 0x66, 0x60, 0x6E, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // H (0x48)
            [0x00, 0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // I (0x49)
            [0x00, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // J (0x4A)
            [0x00, 0x1E, 0x0C, 0x0C, 0x0C, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // K (0x4B)
            [0x00, 0x66, 0x36, 0x1E, 0x1E, 0x36, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // L (0x4C)
            [0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // M (0x4D)
            [0x00, 0xC3, 0xC3, 0xA5, 0xA5, 0x99, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // N (0x4E)
            [0x00, 0x66, 0xE6, 0xF6, 0xDE, 0xCE, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // O (0x4F)
            [0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // P (0x50)
            [0x00, 0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // Q (0x51)
            [0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x60, 0x00, 0x00],
            // R (0x52)
            [0x00, 0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // S (0x53)
            [0x00, 0x3C, 0x66, 0x60, 0x3C, 0x06, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // T (0x54)
            [0x00, 0x7E, 0x5A, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // U (0x55)
            [0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // V (0x56)
            [0x00, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // W (0x57)
            [0x00, 0x66, 0x66, 0x66, 0x66, 0xA5, 0xC3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // X (0x58)
            [0x00, 0x66, 0x3C, 0x18, 0x18, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // Y (0x59)
            [0x00, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // Z (0x5A)
            [0x00, 0x7E, 0x66, 0x0C, 0x18, 0x30, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // [ (0x5B)
            [0x00, 0x3C, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // \ (0x5C)
            [0x00, 0x00, 0x00, 0x00, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // ] (0x5D)
            [0x00, 0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // ^ (0x5E)
            [0x00, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // _ (0x5F)
            [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00],
            // ` (0x60)
            [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // a (0x61)
            [0x00, 0x00, 0x00, 0x00, 0x3C, 0x06, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // b (0x62)
            [0x00, 0x66, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // c (0x63)
            [0x00, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // d (0x64)
            [0x00, 0x66, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // e (0x65)
            [0x00, 0x00, 0x00, 0x00, 0x7E, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // f (0x66)
            [0x00, 0x3C, 0x66, 0x60, 0x7C, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // g (0x67)
            [0x00, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x66, 0x3C, 0x06, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00],
            // h (0x68)
            [0x00, 0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // i (0x69)
            [0x00, 0x18, 0x18, 0x00, 0x38, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // j (0x6A)
            [0x00, 0x06, 0x06, 0x00, 0x0E, 0x06, 0x06, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // k (0x6B)
            [0x00, 0x66, 0x36, 0x1E, 0x1E, 0x36, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // l (0x6C)
            [0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // m (0x6D)
            [0x00, 0x00, 0x00, 0x00, 0xC3, 0xA5, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // n (0x6E)
            [0x00, 0x00, 0x00, 0x00, 0x7C, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // o (0x6F)
            [0x00, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // p (0x70)
            [0x00, 0x00, 0x00, 0x00, 0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // q (0x71)
            [0x00, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x66, 0x3C, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // r (0x72)
            [0x00, 0x00, 0x00, 0x00, 0x7C, 0x66, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // s (0x73)
            [0x00, 0x00, 0x00, 0x00, 0x3C, 0x60, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // t (0x74)
            [0x00, 0x30, 0x30, 0x7C, 0x30, 0x30, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // u (0x75)
            [0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // v (0x76)
            [0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // w (0x77)
            [0x00, 0x00, 0x00, 0x00, 0x66, 0xA5, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // x (0x78)
            [0x00, 0x00, 0x00, 0x00, 0x66, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // y (0x79)
            [0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x3C, 0x06, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // z (0x7A)
            [0x00, 0x00, 0x00, 0x00, 0x7E, 0x0C, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // { (0x7B)
            [0x00, 0x00, 0x00, 0x00, 0x3C, 0x30, 0x30, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // | (0x7C)
            [0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // } (0x7D)
            [0x00, 0x00, 0x00, 0x00, 0x3C, 0x0C, 0x0C, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            // ~ (0x7E)
            [0x00, 0x00, 0x00, 0x00, 0x00, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        ];

        let idx = (char_code - 0x20) as usize;
        if idx < patterns.len() {
            patterns[idx].clone()
        } else {
            [0x00; 16]
        }
    }

    /// Reset the NES system
    pub fn reset(&mut self) {
        self.cpu.reset();
        self.ppu = PPU::new();
        self.apu.reset();
        self.frame_count = 0;
        self.cycle_count = 0;
    }

    /// Run one CPU instruction
    pub fn run_cpu(&mut self) -> u8 {
        let cycles = self.cpu.emulate();
        self.cycle_count += cycles as u64;
        cycles
    }

    /// Run PPU for specified cycles
    pub fn run_ppu(&mut self, cycles: u64) {
        self.ppu.run_cycles(cycles);
    }

    /// Run APU for specified cycles
    pub fn run_apu(&mut self, cycles: u64) {
        // Clock frame counter
        self.apu.clock_frame_counter(cycles);

        // Update channels
        self.apu.update_channels();
    }

    /// Handle a single CPU/PPU/APU cycle
    pub fn cycle(&mut self) {
        // Run CPU instruction
        let cpu_cycles = self.run_cpu();

        // PPU runs at 3x CPU speed
        let ppu_cycles = cpu_cycles as u64 * 3;

        self.run_ppu(ppu_cycles);
        self.run_apu(cpu_cycles as u64);
    }

    /// Run one complete frame
    pub fn frame(&mut self) {
        self.ppu.start_frame();

        // Safety limit to prevent infinite loop
        let max_cycles = 341 * 262 * 2; // More than 2 frames worth of cycles
        let mut total_cycles: u64 = 0;
        let mut loop_iterations: u64 = 0;

        // Main emulation loop
        loop {
            loop_iterations += 1;

            if total_cycles > max_cycles {
                // Safety limit reached - break out to prevent freeze
                eprintln!("FRAME LOOP SAFETY LIMIT REACHED: scanline={}, total_cycles={}", self.ppu.scanline, total_cycles);
                break;
            }

            // Debug: print PPU state periodically
            if loop_iterations == 1 && self.debug {
                eprintln!("CPU: PC=${:04X}, Cycles={}", self.cpu.registers.pc, self.cpu.cycles);
                eprintln!("PPU: scanline={}, cur_x={}, bg_visible={}, sprite_visible={}",
                    self.ppu.scanline, self.ppu.cur_x, self.ppu.bg_visible, self.ppu.sprite_visible);
                self.ppu.debug = true;  // Enable PPU debug
            }
            if self.debug && loop_iterations > 10000 {
                eprintln!("CPU: PC=${:04X}, Cycles={}", self.cpu.registers.pc, self.cpu.cycles);
                eprintln!("PPU: scanline={}, cur_x={}, bg_visible={}, sprite_visible={}",
                    self.ppu.scanline, self.ppu.cur_x, self.ppu.bg_visible, self.ppu.sprite_visible);
                break;  // Break after first debug print
            }

            if self.cpu.cycles_to_halt == 0 {
                // Run CPU instruction
                let cycles = self.cpu.emulate();
                let ppu_cycles = cycles as u64 * 3;

                // Update APU
                self.apu.clock_frame_counter(cycles as u64);

                // Update PPU
                self.ppu.run_cycles(ppu_cycles);

                total_cycles += cycles as u64;

                // Check if frame ended
                if self.ppu.frame_complete {
                    break;
                }

                // Safety check: if we've done too many iterations without progress, break
                if loop_iterations > 50000 {
                    eprintln!("Loop iteration safety limit reached: scanline={}, total_cycles={}, loop_iterations={}", self.ppu.scanline, total_cycles, loop_iterations);
                    break;
                }
            } else {
                // PPU catchup phase
                let cycles = self.cpu.cycles_to_halt.min(8) as u64;
                self.apu.clock_frame_counter(cycles);
                self.ppu.run_cycles(cycles * 3);
                self.cpu.cycles_to_halt -= cycles as u64;
                total_cycles += cycles;
            }
        }

        self.frame_count += 1;
        self.ppu.frame_complete = false;

        // Output frame buffer
        if let Some(ref callback) = self.on_frame {
            callback(&self.ppu.frame_buffer);
        }

        // Generate audio
        if let Some(ref callback) = self.on_audio_sample {
            let (left, right) = self.apu.get_output();
            callback(left as f32 / 32768.0, right as f32 / 32768.0);
        }
    }

    /// Process controller input
    pub fn process_frame(&mut self) {
        // Process APU frame steps based on current scanline
        let scanline = self.ppu.scanline as u64;

        // Check for frame counter steps
        let _step = self.apu.frame_counter.get_step();

        match self.apu.frame_counter.count_sequence {
            0 => {
                // 4-step sequence
                if scanline == 20 {
                    self.apu.clock_quarter_frame();
                } else if scanline == 63 {
                    self.apu.clock_half_frame();
                } else if scanline == 112 {
                    self.apu.clock_quarter_frame();
                } else if scanline == 162 {
                    self.apu.clock_half_frame();
                }
            }
            1 => {
                // 5-step sequence
                if scanline == 20 {
                    self.apu.clock_quarter_frame();
                } else if scanline == 63 {
                    self.apu.clock_half_frame();
                } else if scanline == 112 {
                    self.apu.clock_quarter_frame();
                } else if scanline == 162 {
                    self.apu.clock_half_frame();
                } else if scanline == 211 {
                    self.apu.clock_quarter_frame();
                    self.apu.clock_half_frame();
                }
            }
            _ => {}
        }
    }

    /// Get frame buffer
    pub fn get_frame_buffer(&self) -> &[u32] {
        &self.ppu.frame_buffer
    }

    /// Set button state for controller 1
    pub fn button1_down(&mut self, button: u8) {
        self.controllers.button1_down(button);
    }

    pub fn button1_up(&mut self, button: u8) {
        self.controllers.button1_up(button);
    }

    /// Set button state for controller 2
    pub fn button2_down(&mut self, button: u8) {
        self.controllers.button2_down(button);
    }

    pub fn button2_up(&mut self, button: u8) {
        self.controllers.button2_up(button);
    }

    /// Write to PPU register
    pub fn write_ppu(&mut self, address: u16, value: u8) {
        self.ppu.write(address, value);
    }

    /// Read from PPU register
    pub fn read_ppu(&mut self, address: u16) -> u8 {
        self.ppu.read(address)
    }

    /// Write to APU register
    pub fn write_apu(&mut self, address: u16, value: u8) {
        self.apu.write(address, value);
    }

    /// Read from APU register
    pub fn read_apu(&mut self, address: u16) -> u8 {
        self.apu.read(address)
    }

    /// Write to controller register
    pub fn write_controller(&mut self, address: u16, value: u8) {
        match address {
            0x4016 => self.controllers.strobe1_write(value),
            0x4017 => self.controllers.strobe2_write(value),
            _ => {}
        }
    }

    /// Read from controller register
    pub fn read_controller(&mut self, address: u16) -> u8 {
        match address {
            0x4016 => self.controllers.read1(),
            0x4017 => self.controllers.read2(),
            _ => 0,
        }
    }
}

impl Default for NES {
    fn default() -> Self {
        Self::new(44100)
    }
}

// Test utilities
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cpu_reset() {
        let mut cpu = CPU::new();
        assert_eq!(cpu.registers.sp, 0xFD);
        assert!(cpu.flags.zero);
        assert!(cpu.flags.interrupt);
    }

    #[test]
    fn test_ppu_init() {
        let ppu = PPU::new();
        assert_eq!(ppu.scanline, -1);
        assert_eq!(ppu.cur_x, 0);
    }
}